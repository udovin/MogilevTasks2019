\documentclass[12pt]{article}
\input{contests/settings.tex}
\begin{document}
\Editorial{Ваучеры Фибоначчи}{3}

Преобразуем эту задачу в другую. Во-первых заметим, что если число можно представить в виде суммы $k$ чисел Фибоначчи, то его можно представить и
в виде суммы $k+1$ числа Фибоначчи (за исключением чисел $\le k$). А это значит, что можно свести исходную задачу к такой: найти $(n+k-1)$-е число ($n'$),
которое можно представить в виде суммы \textbf{не более чем} $k$ чисел Фибоначчи.

Сделаем ряд несложных наблюдений:
\begin{itemize}
	\item 
	Любое число можно представить в виде суммы \textbf{различных} чисел Фибоначчи.
	Это можно понять сделав следующее наблюдение (не доказательство):
	$n = 2 \cdot F_i = F_i + F_i = (F_{i-2} + F_{i-1}) + F_i = F_{i-2} + F_{i+1}$.
	\item
	Любое число можно представить в виде битовой маски, где $i$-й бит равен $1$, если в разложении есть $F_i$, иначе~--- $0$.
	Более того, его можно представить в виде такой маски, что никаких рядом стоящих $1$ не будет. Такая маска будет уникальна
	для каждого числа (\textit{представление числа в Фибоначчиевой системе счисления}).
	\item
	Количество единиц в Фибоначчиевой системе счисления дает \textbf{минимальное} количество чисел Фибоначчи, необходимое для представления
	данного числа.
\end{itemize}

Теперь научимся находить количество масок длины $i$ таких, что никакие две $1$ не стоят рядом и их не больше $j$:

$f[i][j] = f[i][j - 1] + (f[i - 1][j] - f[i - 1][j - 1]) + (f[i - 2][j - 1] - f[i - 2][j - 2])$

Теперь будем восстанавливать ответ в Фибоначчиевой системе счисления начиная от старших бит. Для $i$-го (для 0-нумерации) бита будем ставить $1$, если
$f[i][k] \le n'$, иначе $0$. В первом случае не забываем вычесть $f[i][k]$ из $n'$ и $1$ из $k$.

\EndEditorial

\Editorial{Сжатие}{1.33}

На $60$ баллов перебираем левую и правую границу, считаем модуль, если надо, то увеличиваем ответ на $1$.

На $100$ баллов мы будем для каждого $i$, $(1 \le i \le n)$ считать количество таких чисел, что их модуль в точности равен $j$, ($0 \le j \le m - 1$).
Тогда для заметим переход из $dp[i][j]$ в $dp[i + 1][(j * 10 + s[i]) mod m]$, где $s[i]$~--- $i$-ый символ строки $s$.
Также стоит обратить внимание на то, что мы можем хранить только последний слой динамики, в противном случае мы превышаем ограничение по памяти.

\EndEditorial

\Editorial{Новый ноутбук}{2.33}

На $30$ баллов перебираем все возможные варианты строк.

Затем заметим, что второй символ в строке $a_i$ не влияет на конечный результат.

На $100$ баллов мы будем для каждого $i$, $(1 \le i \le n)$ считать количество таких строк, что их $i$-ый символ в точности равен $j$-ому в алфовитном порядке, ($0 \le j \le 26$).
Тогда для заметим переход из $dp[i][j]$ мы можем перейти в клетки согласно правилам, описаным во входных данных. Т. е. из $dp[i][j]$ мы можем перейти в $dp[i + 1][k]$,
где $j$~--- первый символ строки $a_t$, а $k$~--- символ $b_t$.
Также стоит обратить внимание на то, что возможно несколько одинаковых пар $a_i, b_i$. В таком случае лучше сжать значения.

\EndEditorial

\Editorial{Супер М}{2.33}

На $60$ баллов подвешиваем дерево за каждую вершину и считаем ответ.

Заметим, что что-то похожее было на области.

На $100$ баллов мы запустим 2 поиска в глубину. Подвесим дерево за вершину 1.
Сначала мы посчитаем количество атакуемых городов и суммарное расстояние до них в поддереве для каждой вершины.
Затем запустим 2 поиск в глубину и будем сохранять ответ и передавать в поиск глубину количество атакуемых городов и суммарное расстояние до них для всех вершин, кроме вершин поддерева, в которое мы переходим.

\EndEditorial

\end{document}
